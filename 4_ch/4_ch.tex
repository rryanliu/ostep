\documentclass{article}
\usepackage{amsmath, amssymb, graphicx, parskip}
\title{4. The Abstraction: The Process}
\author{Ryan Liu}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{claim}{Claim}[section]
\newtheorem{subclaim}{Subclaim}[claim]
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}

\renewcommand{\thesubsection}{\thesection.\alph{subsection}}


\begin{document}
\maketitle
\thispagestyle{empty}
\newpage
\pagenumbering{arabic}

\setcounter{section}{4}
\section*{}

A process is an instance of a program.
The program itself is just text on the disk.

If a program is a fitness program, a process is a workout

The main problem to solve is providing the illusion of many CPUs, one to each process, with only a few physical CPUs available.
The OS achieves this by \textbf{virtualizing} the CPU --- by running one process, then stopping it and running another, etc. (\textbf{time sharing} the CPU).

The cost is performance; say n processes run round-robin, each is now slowed by a factor of n if they are all CPU bound.

To implement virtualization of the CPU, the OS utilizes low-level machinery (\textbf{mechanisms}, e.g. \textbf{context switch}) as well as high-level intelligence.

\textbf{Policies} are algorithms by which the CPU decides things, including deciding which program should run at what time and for how long.

\end{document}
