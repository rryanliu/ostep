\documentclass{article}
\usepackage{amsmath, amssymb, graphicx, parskip}
\title{4. The Abstraction: The Process}
\author{Ryan Liu}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{claim}{Claim}[section]
\newtheorem{subclaim}{Subclaim}[claim]
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}

\renewcommand{\thesubsection}{\thesection.\alph{subsection}}


\begin{document}
\maketitle
\thispagestyle{empty}
\newpage
\pagenumbering{arabic}

\setcounter{section}{4}
\section*{}

A process is an instance of a program.
The program itself is just text on the disk.

If a program is a fitness program, a process is a workout

The main problem to solve is providing the illusion of many CPUs, one to each process, with only a few physical CPUs available.
The OS achieves this by \textbf{virtualizing} the CPU --- by running one process, then stopping it and running another, etc. (\textbf{time sharing} the CPU).

The cost is performance; say n processes run round-robin, each is now slowed by a factor of n if they are all CPU bound.

To implement virtualization of the CPU, the OS utilizes low-level machinery (\textbf{mechanisms}, e.g. \textbf{context switch}) as well as high-level intelligence.

\textbf{Policies} are algorithms by which the CPU decides things,including how to time-share the CPU and space-share memory.

\subsection{The Abstraction: A Process}

To understand what constitutes a process, we have to understand its \textbf{machine state}: what a program can read or update when it is running.
Much like how my sense of self extends not only to my body, but my place in the world.

One component is obviously memory.
Instructions, data read/written to, sit in memory.
The process' \textbf{address space} is the memory the process can address.

Some registers are special.
The \textbf{program counter (PC) / instruction pointer (IP)} points to the next instruction to execute.

\end{document}
